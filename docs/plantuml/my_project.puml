@startuml
!define RECTANGLE_PACKAGE
skinparam dpi 300
skinparam packageStyle rect
skinparam wrapWidth 400
left to right direction
scale 0.75





/' Objects '/

class BoardStateSummarizer <template<typename ConcreteBoardStateSummarizer, typename KeyType>> {
	+GetState() : ZobristKey_t
	+GetTrData(int search_depth) : moveselection::TranspositionTableSearchResult
	+GetTrTableSize() : moveselection::TranspositionTableSize
	+FullBoardStateCalc(const BoardMap_t& board_map) : void
	+RecordTrData(int search_depth, moveselection::MinimaxResultType result_type, moveselection::EqualScoreMoves& similar_moves) : void
	+UpdateBoardState(const ExecutedMove& move) : void
}


class JsonUtility <template<typename ConcreteJsonUtility>> {
	+Export(T& object, const string file_path) : void
	+Export(piecepoints::BPOPointsSKeys& bpo_points, const string file_path) : void
	+Import(T& object, const string file_path) : void
	+Import(piecepoints::BPOPointsSKeys& bpo_points, const string file_path) : void
}


class MoveEvaluator <template<typename ConcreteMoveEvaluator>> {
	+SelectMove(MoveCollection& allowed_moves) : gameboard::Move
}


class PieceValueProvider <template<typename ConcretePieceValueProvider>> {
	+GetValueOfPieceAtPosition(PieceColor color, PieceType piece_type, BoardSpace space) : Points_t
}


class SpaceInfoProvider <template<typename ConcreteSpaceInfoProvider>> {
	+ExecuteMove(Move move) : ExecutedMove
	+CalcFinalMovesOf(PieceColor color) : MoveCollection
	+GetColor(BoardSpace space) : PieceColor
	+GetType(BoardSpace space) : PieceType
	+IsDraw() : bool
	+GetAllSpacesOccupiedBy(PieceColor color) : vector<BoardSpace>
	+AttachMoveCallback(function<void ( ExecutedMove )> callback) : void
	+UndoMove(ExecutedMove executed_move) : void
}


namespace piecepoints {
	class BPOPointsEKeys {
		+BPOPointsEKeys(TeamBasePoints_t black_base_input, TeamBasePoints_t red_base_offsets_input, TeamPointsEMap_t black_position_input, TeamPointsEMap_t red_position_offsets_input)
		+BPOPointsEKeys(BPOPointsSKeys external_spec)
		+ToGamePointsArray() : GamePointsArray_t
		+black_base_ : TeamBasePoints_t
		+red_base_offsets_ : TeamBasePoints_t
		+BlackNetPoints() : TeamPointsArray_t
		+RedNetPoints() : TeamPointsArray_t
		+black_position_ : TeamPointsEMap_t
		+red_position_offsets_ : TeamPointsEMap_t
	}

	class BPOPointsSKeys {
		+BPOPointsSKeys()
		+BPOPointsSKeys(BasePointsSMap_t black_base_input, BasePointsSMap_t red_base_offsets_input, TeamPointsSMap_t black_position_input, TeamPointsSMap_t red_position_offsets_input)
		+BPOPointsSKeys(const string& json_file_path)
		+ToBPOPointsEKeys() : BPOPointsEKeys
		+black_base_ : BasePointsSMap_t
		+red_base_offsets_ : BasePointsSMap_t
		+ToGamePointsArray() : GamePointsArray_t
		+ToGamePointsSmap() : GamePointsSMap_t
		+black_position_ : TeamPointsSMap_t
		+red_position_offsets_ : TeamPointsSMap_t
		-json_utility_ : unique_ptr<JsonUtility<jsonio::NlohmannJsonUtility>>
		+ToFile(string output_path) : void
	}

	class PiecePositionPoints {
		+PiecePositionPoints()
		+PiecePositionPoints(GamePointsArray_t game_points_array)
		+PiecePositionPoints(BPOPointsEKeys& bpo_points_ekeys)
		+PiecePositionPoints(BPOPointsSKeys& bpo_points_skeys)
		+PiecePositionPoints(string json_file)
		+points_array : GamePointsArray_t
		+PointsArraytoEMap() : GamePointsEMap_t
		+PointsArrayToSmap() : GamePointsSMap_t
		+ImplementGetValueOfPieceAtPosition(PieceColor color, PieceType piece_type, BoardSpace space) : Points_t
		+{static} TeamPointsArrayToEMap(TeamPointsArray_t team_array) : TeamPointsEMap_t
	}
}


namespace moveselection {
	class MinimaxMoveEvaluator <template<typename ConcreteSpaceInfoProvider, typename ConcreteBoardStateSummarizer, typename ConcretePieceValueProvider>> {
		-MinimaxMoveEvaluator(PieceColor evaluating_player, int starting_search_depth, ConcreteSpaceInfoProvider& game_board, const ConcretePieceValueProvider& game_position_points, uint32_t zkey_seed)
		+MinimaxMoveEvaluator(PieceColor evaluating_player, int starting_search_depth, ConcreteSpaceInfoProvider& game_board, const ConcretePieceValueProvider& game_position_points)
		+MinimaxMoveEvaluator(PieceColor evaluating_player, int starting_search_depth, ConcreteSpaceInfoProvider& game_board, uint32_t zkey_seed)
		+MinimaxMoveEvaluator(PieceColor evaluating_player, int starting_search_depth, ConcreteSpaceInfoProvider& game_board)
		-hash_calculator_ : ConcreteBoardStateSummarizer
		+hash_calculator() : ConcreteBoardStateSummarizer& {query}
		-game_position_points_ : ConcretePieceValueProvider
		-game_board_ : ConcreteSpaceInfoProvider&
		-EvaluateEndOfGameLeaf(PieceColor cur_player, MinimaxResultType& result_type) : EqualScoreMoves
		-EvaluateNonWinLeaf(PieceColor cur_player, MinimaxResultType& result_type) : EqualScoreMoves
		-FinalizeNodeResult(MinimaxResultType& result_type, int best_eval, MoveCollection best_moves, int remaining_search_depth, SearchSummary& search_summary) : EqualScoreMoves
		-HandleEndOfGame(PieceColor cur_player, SearchSummary& search_summary, MinimaxResultType& result_type, int remaining_search_depth) : EqualScoreMoves
		-HandleInternalNode(PieceColor cur_player, MoveCollection& allowed_moves, int& remaining_search_depth, int& alpha, int& beta, MinimaxResultType result_type, SearchSummary& search_summary, bool use_transposition_table) : EqualScoreMoves
		-HandleLeaf(PieceColor cur_player, SearchSummary& search_summary, MinimaxResultType& result_type, int remaining_search_depth) : EqualScoreMoves
		-HandleTrTableHit(SearchSummary& search_summary, MinimaxResultType& result_type, TranspositionTableSearchResult& tr_table_search_result, int remaining_search_depth) : EqualScoreMoves
		-MinimaxRec(MoveCollection& allowed_moves, int remaining_search_depth, int alpha, int beta, PieceColor cur_player, SearchSummary& search_summary, bool use_transposition_table) : EqualScoreMoves
		+ImplementSelectMove(MoveCollection& allowed_moves) : Move
		-evaluating_player_ : PieceColor
		-GetPlayerTotal(PieceColor color) : Points_t
		-GetValueOfPieceAtPosition(PieceColor color, PieceType piece_type, BoardSpace space) : Points_t
		-RateMove(Move move, PieceColor cur_player) : ScoredMove
		-RunFirstSearch(MoveCollection& allowed_moves) : SearchSummary&
		-RunSecondSearch(MoveCollection& allowed_moves) : SearchSummary&
		-IsImprovement(int cur_eval, int previous_best_eval, PieceColor cur_player) : bool
		-IsPrunable(int& alpha, int& beta, MinimaxResultType& result_type, PieceColor cur_player) : bool
		-IsPrunableForEvaluator(int& alpha, int& beta, MinimaxResultType& result_type) : bool
		-IsPrunableForEvaluatorOpponent(int& alpha, int& beta, MinimaxResultType& result_type) : bool
		-ValidateMove(SearchSummary& search_summary, MoveCollection& allowed_moves) : bool
		-InitializedBestEval(PieceColor cur_player) : int
		-RecursivelyVisitNodes(Move move, PieceColor cur_player, MoveCollection& allowed_moves, int remaining_search_depth, int alpha, int beta, SearchSummary& search_summary, bool use_transposition_table) : int
		+StartingSearchDepth() : int
		-num_move_selections_ : int
		-starting_search_depth_ : int
		-search_summaries_ : moveselection::SearchSummaries
		+search_summaries() : moveselection::SearchSummaries&
		+KeySizeBits() : size_t
		+board_state_hex_str() : std::string
		-GenerateRankedMoveList(PieceColor cur_player, MoveCollection& cur_player_moves) : std::vector<ScoredMove>
		+zkeys_seed() : uint32_t
		-IncrementNumMoveSelections() : void
		-RunMinimax(MoveCollection& allowed_moves, SearchSummary& search_summary, bool use_transposition_table) : void
		-UpdateAlpha(int& alpha, int cur_eval) : void
		-UpdateBestMoves(PieceColor cur_player, Move move, MoveCollection& best_moves, int cur_eval, int& previous_best_eval) : void
		-UpdateBeta(int& beta, int cur_eval) : void
		-UpdatePruningParam(int& alpha, int& beta, int cur_eval, PieceColor cur_player) : void
	}

	class RandomMoveEvaluator <template<typename ConcreteSpaceInfoProvider>> {
		+RandomMoveEvaluator(PieceColor evaluating_player, ConcreteSpaceInfoProvider& game_board)
		-game_board_ : ConcreteSpaceInfoProvider&
		+ImplementSelectMove(MoveCollection& allowed_moves) : Move
		-evaluating_player_ : PieceColor
	}

	class ResultDepthCounts {
		+ResultDepthCounts(int max_search_depth)
		+data() : ResultDepthCountsData_t
		-data_ : moveselection::ResultDepthCountsData_t
		+IncrementDataAt(MinimaxResultType result_type, int search_depth) : void
	}

	class SearchSummary {
		+SearchSummary(int max_search_depth, TranspositionTableSize tr_table_size_initial)
		+similar_moves() : EqualScoreMoves
		-similar_moves_ : EqualScoreMoves
		+selected_move() : Move
		-selected_move_ : Move
		-result_depth_counts_ : ResultDepthCounts
		-transposition_table_hits_ : ResultDepthCounts
		+GetResultDepthCounts() : ResultDepthCountsData_t
		+GetTranspositionTableHits() : ResultDepthCountsData_t
		+tr_table_size_final() : TranspositionTableSize
		-tr_table_size_final_ : TranspositionTableSize
		+tr_table_size_initial() : TranspositionTableSize
		-tr_table_size_initial_ : TranspositionTableSize
		+returned_illegal_move() : bool
		-returned_illegal_move_ : bool
		+num_collisions() : int
		-num_collisions_ : int
		+num_nodes() : int
		-num_nodes_ : int
		+time() : std::chrono::duration<double , std::nano>
		-time_ : std::chrono::duration<double, std::nano>
		+RecordNodeInfo(MinimaxResultType result_type, int search_depth, EqualScoreMoves& similar_moves) : void
		+RecordTrTableHit(TranspositionTableSearchResult& tr_table_search_result, int remaining_search_depth) : void
		+SetSelectedMove(Move selected_move) : void
		+UpdateTranspositionTableHits(MinimaxResultType result_type, int search_depth) : void
		+set_returned_illegal_move(bool status) : void
		+set_similar_moves(EqualScoreMoves similar_moves) : void
		+set_time(std::chrono::duration<double, std::nano> search_time) : void
		+set_tr_table_size_final(TranspositionTableSize tr_table_size_final) : void
	}

	enum MinimaxResultType {
		kAlphaPrune
		kBetaPrune
		kDraw
		kEvaluatorLoses
		kEvaluatorWins
		kFullyEvaluatedNode
		kMax
		kMin
		kStandardLeaf
		kTrTableHit
		kUnknown
	}

	class CollisionInfo {
		+tr_table_size : TranspositionTableSize
		+board_state : std::string
	}

	class EqualScoreMoves {
		+moves() : MoveCollection
		+similar_moves : MoveCollection
		+shared_score : Points_t
	}

	class ScoredMove {
		+move : Move
		+score : Points_t
	}

	class SearchSummaries {
		+NewExtraSearch(int search_depth, int search_number, TranspositionTableSize tr_table_size_current) : SearchSummary&
		+NewFirstSearch(int search_depth, TranspositionTableSize tr_table_size_initial) : SearchSummary&
		+extra_searches : std::map<int, SearchSummary>
		+first_searches : std::vector<SearchSummary>
	}

	class TranspositionTableEntry {
		+TranspositionTableEntry()
		+TranspositionTableEntry(int depth, MinimaxResultType type, EqualScoreMoves moves)
		+similar_moves : EqualScoreMoves
		+result_type : MinimaxResultType
		+moves() : MoveCollection
		+Score() : Points_t
		+remaining_search_depth : int
	}

	class TranspositionTableSearchResult {
		+score_and_moves() : EqualScoreMoves
		+moves() : MoveCollection
		+table_entry : TranspositionTableEntry
		+IsConsistentWith(MoveCollection& allowed_moves) : bool
		+found : bool
		+known_collision : bool
	}

	class TranspositionTableSize {
		+num_entries : uint64_t
		+num_states : uint64_t
	}
}


namespace jsonio {
	class NlohmannJsonUtility {
		-ImportToSerializedJson(const string file_path) : nlohmann::json
		-Serialize(piecepoints::BPOPointsSKeys& bpo_points) : nlohmann::json
		-Deserialize(nlohmann::json serialized_json, piecepoints::BPOPointsSKeys& bpo_points) : void
		-ExportSerializedJson(nlohmann::json serialized_json, const string file_path) : void
		+ImplementExport(T& object, const string file_path) : void
		+ImplementExport(piecepoints::BPOPointsSKeys& bpo_points, const string file_path) : void
		+ImplementImport(T& object, const string file_path) : void
		+ImplementImport(piecepoints::BPOPointsSKeys& bpo_points, const string file_path) : void
	}
}


namespace gameboard {
	class GameBoard {
		+GameBoard()
		+GameBoard(const BoardMapInt_t starting_board)
		-vector<function<void(ExecutedMove)
		-board_map_ : BoardMap_t
		+map() : BoardMap_t& {query}
		+ImplementExecuteMove(Move move) : ExecutedMove
		+GetOccupantAt(BoardSpace space) : GamePiece {query}
		-move_calculator_ : MoveCalculator
		+ImplementCalcFinalMovesOf(PieceColor color) : MoveCollection
		+ImplementGetColor(BoardSpace space) : PieceColor {query}
		+ImplementGetType(BoardSpace space) : PieceType {query}
		+ImplementIsDraw() : bool
		+IsCaptureMove(ExecutedMove executed_move) : bool
		+IsInCheck(PieceColor color) : bool
		-ViolatesRepeatRule(PieceColor color) : bool
		-moves_since_last_capture_ : int
		+move_log() : std::map<PieceColor , vector<ExecutedMove>>& {query}
		-move_log_ : std::map<PieceColor, vector<ExecutedMove>>
		+ImplementGetAllSpacesOccupiedBy(PieceColor color) : vector<BoardSpace> {query}
		-AddToMoveLog(ExecutedMove executed_move) : void
		+ImplementAttachMoveCallback(const function<void ( ExecutedMove )>& callback) : void
		+ImplementUndoMove(ExecutedMove executed_move) : void
		-RemoveFromMoveLog(ExecutedMove executed_move) : void
		-SetOccupantAt(BoardSpace space, GamePiece piece) : void
		-UpdateStateTracker(ExecutedMove executed_move) : void
	}

	class MoveCalculator {
		+MoveCalculator()
		+CalcAllMovesNoCheckTest(PieceColor color, const BoardMap_t& board_map) : MoveCollection
		-ImplementCalcAllMovesNoCheckTest(PieceColor color, const BoardMap_t& board_map) : MoveCollection
		-piece_dispatch_array_ : PieceDispatchArray_t
		-piece_moves_ : PieceMoves
		+IsOccupied(const BoardMap_t& board_map, const BoardSpace& space) : bool
		+CalcMovesFrom(const BoardSpace space, MoveCollection& team_moves, const BoardMap_t& board_map) : void
		-ImplementCalcMovesFrom(const BoardSpace space, MoveCollection& team_moves, const BoardMap_t& board_map) : void
	}

	class PieceMoves {
		-{static} FwdDirection(PieceColor color) : BoardDirection
		-{static} ExistsAndPassesColorTest(const BoardMap_t& board_map, const BoardSpace& space, PieceColor moving_piece_color) : bool
		+AdvisorMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
		+CannonMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
		+ChariotMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
		+ElephantMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
		+FlyingGeneralMove(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
		+GeneralMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
		+HorseMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
		+SoldierMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
		+StandardGeneralMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
	}

	enum PieceColor {
		kBlk
		kNul
		kRed
	}

	enum PieceType {
		kAdv
		kCan
		kCha
		kEle
		kGen
		kHor
		kNnn
		kSol
	}

	class BoardDirection {
		+file : int
		+rank : int
	}

	class BoardSpace {
		+operator+(const BoardDirection direction) : BoardSpace {query}
		+IsInCastleOf(const PieceColor color) : bool {query}
		+IsInHomelandOf(const PieceColor color) : bool {query}
		+IsOnBoard() : bool {query}
		+operator!=(const BoardSpace other) : bool {query}
		+operator==(const BoardSpace other) : bool {query}
		+file : int
		+rank : int
	}

	class CastleEdges {
		+max_file : int
		+max_rank : int
		+min_file : int
		+min_rank : int
	}

	class ExecutedMove {
		+spaces : Move
		+operator==(const ExecutedMove other) : bool
		+destination_piece : gameboard::GamePiece
		+moving_piece : gameboard::GamePiece
		+moves_since_last_capture : int
	}

	class GamePiece {
		+GamePiece()
		+GamePiece(int int_piece)
		+GamePiece(PieceType type, PieceColor color)
		+piece_color : PieceColor
		+piece_type : PieceType
		+operator==(const GamePiece& other) : bool {query}
	}

	class Move {
		+operator==(const Move other) : bool
		+end : gameboard::BoardSpace
		+start : gameboard::BoardSpace
	}

	class MoveCollection {
		+MoveCollection()
		+MoveCollection(vector<Move> my_moves)
		+MoveCollection(size_t reserve_size)
		+ContainsAnyMoveNotIn(const MoveCollection& other) : bool
		+ContainsDestination(const gameboard::BoardSpace& space) : bool
		+ContainsMove(const Move& move) : bool {query}
		+IsEmpty() : bool
		+Size() : size_t {query}
		+moves : vector<Move>
		+Append(Move move) : void
		+Concat(vector<Move> other_moves) : void
		+Concat(MoveCollection other) : void
	}
}


namespace boardstate {
	class DualKeyTranspositionTable <template<typename KeyType>> {
		+GetDataAt(KeyType board_state, KeyType expected_confirmation_state, int remaining_search_depth) : TranspositionTableSearchResult
		+num_states() : size_t
		+num_entries() : uint64_t
		-data_ : unordered_map<KeyType, DualKeyTranspositionTableEntry<KeyType>>
		+RecordData(KeyType board_state, KeyType confirmation_state, int search_depth, MinimaxResultType result_type, EqualScoreMoves& similar_moves) : void
	}

	class DualZobristTracker <template<typename KeyType>> {
		+DualZobristTracker(ZobristCalculator<KeyType> primary_calculator, ZobristCalculator<KeyType> confirmation_calculator)
		+DualZobristTracker(uint32_t zkeys_seed)
		+DualZobristTracker()
		-transposition_table_ : DualKeyTranspositionTable<KeyType>
		+ImplementGetState() : KeyType
		+board_state() : KeyType
		+ImplementGetTrData(int search_depth) : TranspositionTableSearchResult
		-confirmation_calculator_ : ZobristCalculator<KeyType>
		-primary_calculator_ : ZobristCalculator<KeyType>
		+ImplementGetTrTableSize() : moveselection::TranspositionTableSize
		+board_state_hex_str() : string
		+confirmation_calculator_seed() : uint32_t
		+primary_calculator_seed() : uint32_t
		+zkeys_seed() : uint32_t
		-zkeys_seed_ : uint32_t
		+ImplementFullBoardStateCalc(const BoardMap_t& board_map) : void
		+ImplementRecordTrData(int search_depth, MinimaxResultType result_type, EqualScoreMoves& similar_moves) : void
		+ImplementUpdateBoardState(const ExecutedMove& executed_move) : void
	}

	class PseudoRandomKeyGenerator <template<typename IntType>> {
		+PseudoRandomKeyGenerator()
		+PseudoRandomKeyGenerator(uint32_t seed)
		+GenerateKey() : IntType
		-prng_ : std::mt19937
		+seed() : std::random_device::result_type
		-seed_ : std::random_device::result_type
	}

	class RandomKeyGenerator <template<typename IntType>> {
		+GenerateKey() : IntType
		-rd_ : std::random_device
	}

	class SingleKeyTranspositionTable <template<typename KeyType>> {
		+GetDataAt(KeyType board_state, int remaining_search_depth) : TranspositionTableSearchResult
		+num_states() : size_t
		+num_entries() : uint64_t
		-data_ : unordered_map<KeyType, TranspositionTableEntry>
		+RecordData(KeyType state, int search_depth, MinimaxResultType result_type, EqualScoreMoves& similar_moves) : void
	}

	class SingleZobristTracker <template<typename KeyType>> {
		+SingleZobristTracker(ZobristCalculator<KeyType> calculator)
		+SingleZobristTracker()
		+SingleZobristTracker(uint32_t seed)
		+ImplementGetState() : KeyType
		+board_state() : KeyType
		-transposition_table_ : SingleKeyTranspositionTable<KeyType>
		+ImplementGetTrData(int search_depth) : TranspositionTableSearchResult
		-calculator_ : ZobristCalculator<KeyType>
		+ImplementGetTrTableSize() : moveselection::TranspositionTableSize
		+board_state_hex_str() : string
		+zkeys_seed() : uint32_t
		+ImplementFullBoardStateCalc(const BoardMap_t& board_map) : void
		+ImplementRecordTrData(int search_depth, MinimaxResultType result_type, EqualScoreMoves& similar_moves) : void
		+ImplementUpdateBoardState(const ExecutedMove& executed_move) : void
	}

	class ZobristCalculator <template<typename KeyType>> {
		+ZobristCalculator(uint32_t seed)
		+ZobristCalculator()
		-{static} CreateGameZarray(PseudoRandomKeyGenerator<KeyType>& key_generator) : GameZarray_t
		+zarray() : GameZarray_t
		-zarray_ : GameZarray_t
		+GetHashValueAt(PieceColor color, PieceType piece_type, BoardSpace space) : KeyType
		+board_state() : KeyType
		-board_state_ : KeyType
		+turn_key() : KeyType
		-turn_key_ : KeyType
		+KeysVector() : std::vector<KeyType> {query}
		+seed() : uint32_t
		-seed_ : uint32_t
		+FullBoardStateCalc(const BoardMap_t& board_map) : void
		+UpdateBoardState(ExecutedMove executed_move) : void
	}

	class DualKeyTranspositionTableEntry <template<typename KeyType>> {
		+confirmation_state : KeyType
		+single_key_entry : TranspositionTableEntry
	}
}





/' Inheritance relationships '/

BoardStateSummarizer <|-- boardstate.DualZobristTracker


BoardStateSummarizer <|-- boardstate.SingleZobristTracker


JsonUtility <|-- jsonio.NlohmannJsonUtility


MoveEvaluator <|-- moveselection.MinimaxMoveEvaluator


MoveEvaluator <|-- moveselection.RandomMoveEvaluator


PieceValueProvider <|-- piecepoints.PiecePositionPoints


SpaceInfoProvider <|-- gameboard.GameBoard





/' Aggregation relationships '/

moveselection.CollisionInfo *-- moveselection.TranspositionTableSize


boardstate.DualKeyTranspositionTable *-- boardstate.DualKeyTranspositionTableEntry


boardstate.DualZobristTracker *-- boardstate.DualKeyTranspositionTable


boardstate.DualZobristTracker "2" *-- boardstate.ZobristCalculator


gameboard.ExecutedMove "2" *-- gameboard.GamePiece


gameboard.ExecutedMove *-- gameboard.Move


gameboard.GameBoard *-- gameboard.ExecutedMove


gameboard.GameBoard *-- gameboard.MoveCalculator


gameboard.GamePiece *-- gameboard.PieceColor


gameboard.GamePiece *-- gameboard.PieceType


moveselection.MinimaxMoveEvaluator *-- moveselection.SearchSummaries


gameboard.Move "2" *-- gameboard.BoardSpace


gameboard.MoveCalculator *-- gameboard.PieceMoves


gameboard.MoveCollection *-- gameboard.Move


moveselection.SearchSummaries "2" *-- moveselection.SearchSummary


moveselection.SearchSummary *-- moveselection.EqualScoreMoves


moveselection.SearchSummary "2" *-- moveselection.ResultDepthCounts


moveselection.SearchSummary "2" *-- moveselection.TranspositionTableSize


boardstate.SingleZobristTracker *-- boardstate.SingleKeyTranspositionTable


boardstate.SingleZobristTracker *-- boardstate.ZobristCalculator


moveselection.TranspositionTableEntry *-- moveselection.EqualScoreMoves


moveselection.TranspositionTableEntry *-- moveselection.MinimaxResultType


moveselection.TranspositionTableSearchResult *-- moveselection.TranspositionTableEntry






/' Nested objects '/



@enduml
