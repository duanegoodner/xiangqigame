@startuml
!define RECTANGLE_PACKAGE
skinparam dpi 300
skinparam packageStyle rect
skinparam wrapWidth 500
left to right direction
scale 0.75




/' Objects '/

class BoardStateSummarizer <template<typename ConcreteBoardStateSummarizer, typename KeyType>> {
	+GetTrData(int search_depth) : TranspositionTableSearchResult
	+GetState() : ZobristKey_t
	+FullBoardStateCalc(BoardMap_t& board_map) : void
	+RecordTrData(int search_depth, MinimaxResultType result_type, BestMoves& best_moves) : void
	+UpdateBoardState(const ExecutedMove& move) : void
}


class GameBoard {
	+GameBoard()
	+GameBoard(const BoardMapInt_t starting_board)
	-vector<function<void(ExecutedMove)
	-board_map_ : BoardMap_t
	+map() : BoardMap_t& {query}
	+ImplementExecuteMove(Move move) : ExecutedMove
	+GetOccupant(BoardSpace space) : GamePiece
	-move_calculator_ : MoveCalculator
	+ImplementCalcFinalMovesOf(PieceColor color) : MoveCollection
	+ImplementGetColor(BoardSpace space) : PieceColor
	+ImplementGetType(BoardSpace space) : PieceType
	+IsInCheck(PieceColor color) : bool
	-ViolatesRepeatRule(PieceColor color) : bool
	+GetMoveLog() : std::map<PieceColor , vector<ExecutedMove>>
	-move_log_ : std::map<PieceColor, vector<ExecutedMove>>
	+ImplementGetAllSpacesOccupiedBy(PieceColor color) : vector<BoardSpace>
	-AddToMoveLog(ExecutedMove executed_move) : void
	+ImplementAttachMoveCallback(function<void ( ExecutedMove )> callback) : void
	+ImplementUndoMove(ExecutedMove executed_move) : void
	-RemoveFromMoveLog(ExecutedMove executed_move) : void
	-SetOccupant(BoardSpace space, GamePiece piece) : void
	-UpdateHashCalculator(ExecutedMove executed_move) : void
}


class HashCalculator <template<typename KeyType>> {
	+HashCalculator(ZobristKeys<KeyType> zkeys)
	+HashCalculator()
	+ImplementGetState() : KeyType
	-board_state_ : KeyType
	-transposition_table_ : TranspositionTable<KeyType>
	+ImplementGetTrData(int search_depth) : TranspositionTableSearchResult
	-zkeys_ : ZobristKeys<KeyType>
	+ImplementFullBoardStateCalc(const BoardMap_t& board_map) : void
	+ImplementRecordTrData(int search_depth, MinimaxResultType result_type, BestMoves& best_moves) : void
	+ImplementUpdateBoardState(const ExecutedMove& move) : void
	-_ImplementUpdateBoardState(ExecutedMove move) : void
}


class MinimaxMoveEvaluator <template<typename ConcreteSpaceInfoProvider, typename ConcreteBoardStateSummarizer, typename ConcretePieceValueProvider>> {
	+MinimaxMoveEvaluator(PieceColor evaluating_player, int starting_search_depth, ConcreteSpaceInfoProvider& game_board, ConcretePieceValueProvider game_position_points)
	+MinimaxMoveEvaluator(PieceColor evaluating_player, int starting_search_depth, ConcreteSpaceInfoProvider& game_board)
	-EvaluateEndOfGameLeaf(PieceColor cur_player, MinimaxResultType& result_type) : BestMoves
	-EvaluateNonWinLeaf(PieceColor cur_player) : BestMoves
	-MinimaxRec(int remaining_search_depth, int alpha, int beta, PieceColor cur_player, SearchSummary& single_search_summary, bool use_transposition_table) : BestMoves
	-hash_calculator_ : ConcreteBoardStateSummarizer
	-game_position_points_ : ConcretePieceValueProvider
	-game_board_ : ConcreteSpaceInfoProvider&
	+ImplementSelectMove() : Move
	-RunMinimax(SearchSummary& single_search_summary, bool use_transposition_table) : Move
	-evaluating_player_ : PieceColor
	+GetPlayerTotal(PieceColor color) : Points_t
	-GetValueOfPieceAtPosition(PieceColor color, PieceType piece_type, BoardSpace space) : Points_t
	-RateMove(Move move, PieceColor cur_player) : RatedMove
	+GetSearchSummaries() : SearchSummaries
	-search_summaries_ : SearchSummaries
	+StartingSearchDepth() : int
	-num_move_selections_ : int
	-starting_search_depth_ : int
	+KeySizeBits() : size_t
	-GenerateRankedMoveList(PieceColor cur_player, MoveCollection& cur_player_moves) : std::vector<RatedMove>
}


class MoveCalculator {
	+MoveCalculator()
	+CalcAllMovesNoCheckTest(PieceColor color, const BoardMap_t& board_map) : MoveCollection
	-ImplementCalcAllMovesNoCheckTest(PieceColor color, const BoardMap_t& board_map) : MoveCollection
	-piece_dispatch_array_ : PieceDispatchArray_t
	-piece_moves_ : PieceMoves
	+IsOccupied(const BoardMap_t& board_map, const BoardSpace& space) : bool
	+CalcMovesFrom(const BoardSpace space, MoveCollection& team_moves, const BoardMap_t& board_map) : void
	-ImplementCalcMovesFrom(const BoardSpace space, MoveCollection& team_moves, const BoardMap_t& board_map) : void
}


class MoveEvaluatorInterface <template<typename ConcreteMoveEvaluator>> {
	+SelectMove() : Move
}


class PieceMoves {
	-{static} FwdDirection(PieceColor color) : BoardDirection
	-{static} ExistsAndPassesColorTest(const BoardMap_t& board_map, const BoardSpace& space, PieceColor moving_piece_color) : bool
	+AdvisorMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
	+CannonMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
	+ChariotMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
	+ElephantMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
	+FlyingGeneralMove(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
	+GeneralMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
	+HorseMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
	+SoldierMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
	+StandardGeneralMoves(const BoardMap_t& board_map, PieceColor color, const BoardSpace& space, MoveCollection& team_moves) : void
}


class PieceValueProvider <template<typename ConcretePieceValueProvider>> {
	+GetValueOfPieceAtPosition(PieceColor color, PieceType piece_type, BoardSpace space) : Points_t
}


class RandomMoveEvaluator <template<typename ConcreteSpaceInfoProvider>> {
	+RandomMoveEvaluator(PieceColor evaluating_player, ConcreteSpaceInfoProvider& game_board)
	-game_board_ : ConcreteSpaceInfoProvider&
	+ImplementSelectMove() : Move
	-evaluating_player_ : PieceColor
}


class SpaceInfoProvider <template<typename ConcreteSpaceInfoProvider>> {
	+ExecuteMove(Move move) : ExecutedMove
	+CalcFinalMovesOf(PieceColor color) : MoveCollection
	+GetColor(BoardSpace space) : PieceColor
	+GetType(BoardSpace space) : PieceType
	+GetAllSpacesOccupiedBy(PieceColor color) : vector<BoardSpace>
	+AttachMoveCallback(function<void ( ExecutedMove )> callback) : void
	+UndoMove(ExecutedMove executed_move) : void
}


enum MinimaxResultType {
	kAlphaPrune
	kBetaPrune
	kEvaluatorLoses
	kEvaluatorWins
	kFullyEvaluatedNode
	kMax
	kMin
	kStandardLeaf
	kTrTableHit
	kUnknown
}


enum PieceColor {
	kBlk
	kNul
	kRed
}


enum PieceType {
	kAdv
	kCan
	kCha
	kEle
	kGen
	kHor
	kNnn
	kSol
}


class BestMoves {
	+best_moves : MoveCollection
	+best_eval : Points_t
}


class RatedMove {
	+move : Move
	+rating : Points_t
}


class ResultDepthCounts {
	+ResultDepthCounts(int max_search_depth)
	+data : std::vector<std::vector<int>>
	+Update(MinimaxResultType result_type, int search_depth) : void
}


class SearchSummaries {
	+NewExtraSearch(int search_depth, int search_number) : SearchSummary&
	+NewFirstSearch(int search_depth) : SearchSummary&
	+extra_searches : std::map<int, SearchSummary>
	+first_searches : std::vector<SearchSummary>
}


class SearchSummary {
	+SearchSummary(int max_search_depth)
	+best_moves : BestMoves
	+selected_move : Move
	+result_depth_counts : ResultDepthCounts
	+transposition_table_hits : ResultDepthCounts
	+num_nodes : int
	+time : std::chrono::duration<double, std::nano>
	+GetResultDepthCounts() : std::vector<std::vector<int>>
	+GetTranspositionTableHits() : std::vector<std::vector<int>>
	+SetBestMoves(BestMoves best_moves) : void
	+SetSelectedMove(Move selected_move) : void
	+SetTime(std::chrono::duration<double, std::nano> search_time) : void
	+Update(MinimaxResultType result_type, int search_depth, BestMoves best_moves) : void
	+UpdateTranspositionTableHits(MinimaxResultType result_type, int search_depth) : void
}


class TranspositionTable <template<typename KeyType>> {
	+GetData(KeyType board_state, int remaining_search_depth) : TranspositionTableSearchResult
	-data_ : unordered_map<KeyType, vector<TranspositionTableEntry>>
	+RecordData(KeyType state, int search_depth, MinimaxResultType result_type, BestMoves& best_moves) : void
}


class TranspositionTableEntry {
	+best_moves : BestMoves
	+result_type : MinimaxResultType
	+Score() : Points_t
	+remaining_search_depth : int
}


class TranspositionTableSearchResult {
	+table_entry : TranspositionTableEntry
	+found : bool
}


class ZobristKeys <template<typename KeyType>> {
	+ZobristKeys()
	+ZobristKeys(uint32_t seed)
	+ZobristKeys(KeyType new_turn_key, GameZarray_t& new_zarray)
	+ZobristKeys(json json_object)
	+ZobristKeys(string json_file_path)
	+{static} create_game_zarray(std::mt19937_64& gen_64) : GameZarray_t
	+zarray : GameZarray_t
	+GetHashValue(PieceColor color, PieceType piece_type, BoardSpace space) : KeyType
	+turn_key : KeyType
	+ToJson() : json
}


namespace piece_points {
	class GamePointsArrayBuilder {
		+GamePointsArrayBuilder(PointsSpecBPOInternal internal_points_spec)
		+GamePointsArrayBuilder(PointsSpecBPOExternal external_points_spec)
		+GamePointsArrayBuilder(string spec_file_path)
		+BuildGamePointsArray() : GamePointsArray_t
		-points_spec_ : PointsSpecBPOInternal
		-ComputeBlackNetPoints() : TeamPointsArray_t
		-ComputeRedNetPoints() : TeamPointsArray_t
	}

	class PieceBasePoints {
		+advisor : int
		+cannon : int
		+chariot : int
		+elephant : int
		+general : int
		+horse : int
		+null : int
		+soldier : int
	}

	class PiecePositionPoints {
		+PiecePositionPoints()
		+PiecePositionPoints(GamePointsArray_t game_points_array)
		+PiecePositionPoints(GamePointsSMap_t s_map)
		+PiecePositionPoints(json j)
		+PiecePositionPoints(PointsSpecBPOInternal internal_bpo_spec)
		+PiecePositionPoints(PointsSpecBPOExternal external_bpo_spec)
		+PiecePositionPoints(string json_file)
		+points_array : GamePointsArray_t
		+ImplementGetValueOfPieceAtPosition(PieceColor color, PieceType piece_type, BoardSpace space) : Points_t
		+ToJson() : json
		+ToFile(string output_file) : void
	}

	class PointsSpecBPOExternal {
		+PointsSpecBPOExternal()
		+PointsSpecBPOExternal(BasePointsSMap_t black_base_input, BasePointsSMap_t red_base_offsets_input, TeamPointsSMap_t black_position_input, TeamPointsSMap_t red_position_offsets_input)
		+PointsSpecBPOExternal(json json_object)
		+PointsSpecBPOExternal(string json_file_path)
		+black_base : BasePointsSMap_t
		+red_base_offsets : BasePointsSMap_t
		+ToGamePointsArray() : GamePointsArray_t
		+ToGamePointsSmap() : GamePointsSMap_t
		+black_position : TeamPointsSMap_t
		+red_position_offsets : TeamPointsSMap_t
		+ToJson() : nloh_json
		+ToFile(string output_path) : void
	}

	class PointsSpecBPOInternal {
		+PointsSpecBPOInternal(TeamBasePoints_t black_base_input, TeamBasePoints_t red_base_offsets_input, TeamPointsEMap_t black_position_input, TeamPointsEMap_t red_position_offsets_input)
		+PointsSpecBPOInternal(PointsSpecBPOExternal external_spec)
		+black_base : TeamBasePoints_t
		+red_base_offsets : TeamBasePoints_t
		+black_position : TeamPointsEMap_t
		+red_position_offsets : TeamPointsEMap_t
	}
}


namespace json_io {
	abstract class JsonFileHandler {
		+~JsonFileHandler()
		+{abstract} Validate(string data_file, string schema_file) : bool
		+{abstract} Export(GamePointsSMap_t& data, string file_path) : void
		+{abstract} Export(BPOSpecSMap_t& data, string file_path) : void
		+{abstract} Import(GamePointsSMap_t& s_map, string file_path) : void
		+{abstract} Import(BPOSpecSMap_t& s_map, string file_path) : void
	}

	class NlohmannJsonIO {
		+Validate(string data_file, string schema_file) : bool
		-ImportToJson(string file_path) : nlohmann::json
		+Export(GamePointsSMap_t& data, string file_path) : void
		+Export(BPOSpecSMap_t& data, string file_path) : void
		-ExportFromJson(nlohmann::json j, string file_path) : void
		-ExportWithTemplate(T& object, string file_path) : void
		+Import(GamePointsSMap_t& s_map, string file_path) : void
		+Import(BPOSpecSMap_t& s_map, string file_path) : void
		-ImportWithTemplate(string file_path, T& object) : void
	}
}


namespace board_components {
	class BoardDirection {
		+file : BoardIdx_t
		+rank : BoardIdx_t
	}

	class BoardSpace {
		+file : BoardIdx_t
		+rank : BoardIdx_t
		+operator+(const BoardDirection direction) : BoardSpace {query}
		+IsInCastleOf(const PieceColor color) : bool {query}
		+IsInHomelandOf(const PieceColor color) : bool {query}
		+IsOnBoard() : bool {query}
		+operator!=(const BoardSpace other) : bool {query}
		+operator==(const BoardSpace other) : bool {query}
	}

	class CastleEdges {
		+max_file : BoardIdx_t
		+max_rank : BoardIdx_t
		+min_file : BoardIdx_t
		+min_rank : BoardIdx_t
	}

	class ExecutedMove {
		+destination_piece : GamePiece
		+moving_piece : GamePiece
		+spaces : Move
		+operator==(const ExecutedMove other) : bool
	}

	class GamePiece {
		+GamePiece()
		+GamePiece(int int_piece)
		+GamePiece(PieceType type, PieceColor color)
		+piece_color : PieceColor
		+piece_type : PieceType
		+operator==(const GamePiece& other) : bool {query}
	}

	class Move {
		+end : BoardSpace
		+start : BoardSpace
		+operator==(const Move other) : bool
	}

	class MoveCollection {
		+MoveCollection()
		+MoveCollection(vector<Move> my_moves)
		+MoveCollection(size_t reserve_size)
		+ContainsDestination(const BoardSpace& space) : bool
		+ContainsMove(const Move& move) : bool {query}
		+Size() : size_t {query}
		+moves : vector<Move>
		+Append(Move move) : void
		+Concat(vector<Move> other_moves) : void
		+Concat(MoveCollection other) : void
	}
}





/' Inheritance relationships '/

json_io.JsonFileHandler <|-- json_io.NlohmannJsonIO


BoardStateSummarizer <|-- HashCalculator


MoveEvaluatorInterface <|-- MinimaxMoveEvaluator


MoveEvaluatorInterface <|-- RandomMoveEvaluator


PieceValueProvider <|-- piece_points.PiecePositionPoints


SpaceInfoProvider <|-- GameBoard





/' Aggregation relationships '/

board_components.ExecutedMove "2" *-- board_components.GamePiece


board_components.ExecutedMove *-- board_components.Move


GameBoard *-- MoveCalculator


GameBoard *-- PieceColor


board_components.GamePiece *-- PieceColor


board_components.GamePiece *-- PieceType


piece_points.GamePointsArrayBuilder *-- piece_points.PointsSpecBPOInternal


HashCalculator *-- TranspositionTable


HashCalculator *-- ZobristKeys


MinimaxMoveEvaluator *-- PieceColor


MinimaxMoveEvaluator *-- SearchSummaries


board_components.Move "2" *-- board_components.BoardSpace


MoveCalculator *-- PieceMoves


board_components.MoveCollection *-- board_components.Move


RandomMoveEvaluator *-- PieceColor


SearchSummaries "2" *-- SearchSummary


SearchSummary *-- BestMoves


SearchSummary "2" *-- ResultDepthCounts


TranspositionTable *-- TranspositionTableEntry


TranspositionTableEntry *-- BestMoves


TranspositionTableEntry *-- MinimaxResultType


TranspositionTableSearchResult *-- TranspositionTableEntry






/' Nested objects '/



@enduml
